[{"content":"Javascript 的參數傳遞:\rby reference (傳址/傳參考)、by value（傳值）和 by sharing（傳共享）\r\r 從比較運算子來釐清基本觀念 在正式進入這個主題之前，我們先來複習一下 JavaScript 的基本觀念。首先是「比較運算子」：\n1 2 3  let a = 3; let b = 3; console.log(a === b);   上面這題印出的答案是甚麼呢？沒錯，是 true。\n看到這邊，你可能會想翻桌，這麼簡單的問題還要問嗎？值與型別都相同，用嚴格相等比較運算子（===），結果當然是 true 啊。\n先壓壓怒氣，再來看看下面這題：\n1 2 3  let c = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;]; let d = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;]; console.log(c === d);   「廢話，當然也是 true 啊！」\n你確定嗎？\n那麼下面這幾題呢？\n1 2 3 4  console.log( [] === [] ); console.log( [1] === [1] ); console.log( {} === {} ); console.log( {a:1} === {a:1} );   執行以上五個判斷式的結果是什麼呢？\n結果竟然全部是 false ！\n原因就在於 Javascript 中不同型別的變數會有不同的儲存和傳遞資料的方式，大致上可以分為 「傳值」(call/pass by value) 和 「傳址（也有譯為「傳參考」）」(call/pass by reference) 兩種。\n參數的傳遞方式 以傳統的說法來說，若變數指派的值為基本型別（number、string、boolean、null、undefined、symbol），那麼賦值是「傳值」。\n若變數指派的值為物件型別（object、array、function），那麼賦值是「傳址」。\n   型別 參數傳遞方式 英譯     基本型別（number、string、boolean、null、undefined、symbol） 傳值 by value   物件型別（object、array、function） 傳址/傳參考 by reference    但為什麼說上面這個說法是「傳統說法」呢？\n因為也有人認為 Javascript 既不是傳值也不是傳址，而是「有時看起來像傳值，有時看起來像傳址」， 實際上應該說是「傳共享（pass/call by sharing）」 。\n但也有人認為 Javascript 沒有所謂的「傳址」或「傳共享」，實際上就只有「傳值」(call/pass by value)。\n這眾說紛紜的狀況是怎麼回事呢？要釐清這道經典的爭議題，就讓我們先從傳統的說法來理解何謂「傳值」？何謂「傳址」？\n何謂「傳值（call/pass by value）」？ 對電腦來說，實際儲存和呼叫資料是以「記憶體位址」來運作，而宣告變數，就是來幫助我們以別名來與實際的資料儲存位址作連結。變數會指向記憶體位置來調用資料進行運算。\n1  let a = 3;   比如說，當我們宣告一個變數 a ，並賦值一個資料型別為數字的值 3 的時候，實際上在電腦中是這樣運作的：\n 將 3 這個值儲存在 0x01 這個記憶體位置，然後把變數 a 指向這個記憶體位置。\n如果此時宣告一個新變數 b，並把變數 a 的值賦值給變數 b：\n1 2  let a = 3; let b = a;   那麼記憶體位置 0x01 中儲存的值 3 就會被複製一份到 0x02 ，並將新變數 b 指向記憶體位置 0x02。（如下圖）\n 這就是所謂的「傳值」。\n也就是當 變數指派的值是基本型別 時，變數間做 = 賦值時，傳遞的是變數的值。\n此時，不同變數雖然值相同，但依舊是儲存在不同的記憶體位址。\n若這時對其中一個變數再重新賦值的話，另一個變數的值並不會因此而更動：\n1 2 3 4 5 6 7 8 9 10 11  let a = 3; let b = a; console.log( a ); // 3 console.log( b ); // 3  a = 5; // 變數 b 依然是 3，而變數 a 變成了 5 console.log( a ); // 5 console.log( b ); // 3   \n 當變數的值為基本型別時，若對該變數重新賦值的話，並不是直接修改值的資料內容，而是在記憶體內部重新分配一個區塊存放新的值，變數就指向新分配的記憶體區塊，原本舊的記憶體區塊還是放著舊值，所以舊值其實是不可變動的（immutable）。有 by value 特性的資料型別大多是不可變動的（immutable）。\n何謂「傳址（call/pass by reference）」？ 若變數指派的值為物件型別（object、array、function），那麼賦值就是「傳址」。\n這又是甚麼意思呢？\n因為物件型別儲存的是物件中的每個屬性（property），一個屬性包含一組「鍵」（key）和「值」（value），一組「鍵值對（Key-Value Pairs）」稱做物件的一個屬性。\n這組「鍵值對」儲存的方式是：儲存屬性「鍵（key）」的值 以及 儲存屬性「值（value）」的記憶體位置。（觀念來源：JavaScript - 參數傳遞方式 (2)）\n我將我對這段話的理解，繪製成下圖：\n 也就是變數 obj 指向的記憶體位置 0x03 儲存了一個物件型別的資料，該物件有兩個屬性，第一個屬性的「鍵」 key0 的「值」是記憶體位置 0x01 ，而 0x01 儲存了一個字串型別的資料 \u0026quot;aa\u0026quot;。第二個屬性的「鍵」 key1 的「值」是記憶體位置 0x02 ，而 0x02 儲存了一個字串型別的資料 \u0026quot;bb\u0026quot;。\n若此時欲將變數 obj 的值，賦值給變數 obj2：\n1 2 3 4 5  let obj = { key0: \u0026#34;aa\u0026#34;, key1: \u0026#34;bb\u0026#34; }; let obj2 = obj;   電腦底層的運作方式是如何呢？\n剛剛處理基本型別的值，用的是傳值（call/pass by value）的方式。如果物件型別也用一樣的方法的話，那麼應該就是將記憶體位置 0x03 的物件型別資料複製一份到記憶體位置 0x04，再將變數 obj2 指向記憶體位置 0x04。\n可是，如果我們以這個概念來操作以下程式碼的話，就會發現狀況有點不一樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let obj = { key0: \u0026#34;aa\u0026#34;, key1: \u0026#34;bb\u0026#34; }; // 先將 obj 賦值給 obj2 let obj2 = obj; console.log(obj); // {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;}; console.log(obj2); // {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;};  // 再對 obj 物件的第一個鍵值重新賦值 obj.key0 = \u0026#34;cc\u0026#34;; console.log(obj); // {key0: \u0026#34;cc\u0026#34;,key1: \u0026#34;bb\u0026#34;}; console.log(obj2); // {key0: \u0026#34;cc\u0026#34;,key1: \u0026#34;bb\u0026#34;};  console.log(obj===obj2); // true   如果變數 obj2 指向的是記憶體位置 0x04，那麼第二次 console.log 時，印出來的結果應該會不一樣才對。但是變數 obj 和 變數 obj2 卻印出一樣的結果！\n也就是說，下圖用「傳值」的方式來理解物件型別的參數傳遞是錯誤的：\n 正確的理解是，當變數指派的值是物件型別時，變數間做 = 賦值時，傳遞的是變數的記憶體位址，即所謂「傳址」。\n 這樣的話，剛剛那段程式碼的運作邏輯，就解釋得通了。\nobj.key0 = \u0026quot;cc\u0026quot;; 是將字串 \u0026quot;cc\u0026quot; 儲存在新的記憶體位置，再將 obj.key0 指向新的記憶體位置，但是原先儲存整個物件資料的記憶體位置並沒有變動，由於 obj 和 obj2 儲存的是同一個記憶體位置，所以 obj === obj2 的結果會是 true。\n真正變動的只有屬性的值所指向的記憶體位置。\n 這時我們再回過頭來看，一開始關於嚴格相等比較運算子（===）的那道題目，就可以理解答案是 false 的原因了：\n1 2 3  let c = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;]; let d = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;]; console.log(c === d); // false   因為 變數c 和 變數d 所儲存的物件資料，其值所指向的記憶體空間並不相同，因此嚴格比對下的結果會是 false。\n關於 immutable 和 mutable 的觀念 在上面的例子中，實際修改物件的值時，將會修改到的是物件的值所參考到的記憶體位置，可以發現舊值是可變動的（mutable)。\n這裡就帶出了 「不可變的（immutable）」 和 「可變的（mutable）」 的兩種觀念。\n當變數的值為基本型別時，若要修改值，其實是在記憶體內部重新分配一個區塊存放新的值，而變數就會指向新分配的記憶體區塊，原本舊的記憶體區塊還是放著舊值，所以舊值為 immutable。\n有 by value 特性的資料型別大多是 immutable。\n Object, Array, Function, Map 和 Set 等物件型別，在實際修改物件的值時，將會修改到的是物件的值所參考到的記憶體位置，所以舊值為 mutable。\n有 by reference 特性的型別大多是 mutable。\n 關於 pass by sharing 的討論 而物件型別的「傳址」又還有一個例外情況，故又有討論認為 Javascript 的策略其實不是「傳值（call/pass by value）」，也不是「傳址（call/pass by reference）」而是「傳共享（call/pass by sharing）」。\n這點就見仁見智了，此處對於 Javascript 究竟是不是該歸屬於「pass by sharing」不去細究，想進一步了解的話可再從下方的參考資料中去延伸閱讀。\n此處只對這個例外情況稍作說明，這個例外情況是什麼呢？\n就是當變數的值為物件型別，變數間做 = 賦值時，傳遞的是變數的記憶體位址，即「傳址」，但如果此時又再對其中一個變數用 物件實字（object literal） 的方式重新賦值，或在物件中加入新的 key 屬性的話，那麼，原本指向同一個記憶體位址的兩個變數，其中重新賦值的那個變數會指向不同的記憶體位址來儲存新的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let obj = { key0: \u0026#34;aa\u0026#34;, key1: \u0026#34;bb\u0026#34; }; // 將 obj 的記憶體位址，賦值「傳址」給 obj2 let obj2 = obj; // obj 和 obj2 此時指向同一個記憶體位址 console.log(obj); // {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;}; console.log(obj2); // {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;};  // 以物件實字重新對 obj 賦值 obj = { key3: \u0026#34;cc\u0026#34; }; console.log(obj); // {key3: \u0026#34;cc\u0026#34;}; console.log(obj2); // {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;};  // obj2 仍是 {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;}; // obj 卻被指向新的記憶體位址，且不會影響的 obj2 的值   \n 前一章節探討物件型別的值，有說到物件型別的舊值為「可變動的（mutable）」，但從上面這個例子來看，以物件實字重新賦值時，舊值並非「可變動的（mutable）」，而是指向新的記憶體位置，這個狀況似乎比較像基本型別「不可變動的（immmutable）」性質以及「傳值」的運作方式。\n是不是覺得之前說的「傳值」和「傳址」觀念有點開始崩裂了呢？\n再來看另外一種例外狀況，是經由第三方函式來傳遞參數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 宣告一個物件 obj let obj = { key0: \u0026#34;aa\u0026#34;, key1: \u0026#34;bb\u0026#34; }; function changeObj(xyz){ console.log(xyz);\t// {key0: \u0026#39;aa\u0026#39;, key1: \u0026#39;bb\u0026#39;}  // 對物件的第一個鍵值重新賦值 \txyz.key0 = \u0026#34;cc\u0026#34;; console.log(xyz);\t// {key0: \u0026#39;cc\u0026#39;, key1: \u0026#39;bb\u0026#39;} } // 以第三方函式傳值 changeObj(obj); // obj 的第一個鍵值確實被改動了 console.log(obj);\t// {key0: \u0026#39;cc\u0026#39;, key1: \u0026#39;bb\u0026#39;}   在上面的例子中，因為是「傳址」，所以物件 obj 的第一個鍵值確實被更動了。\n但如果用在第三方函式中以物件實字（object literal）重新賦值呢？卻變成了「傳值」的運作模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 宣告一個物件 obj let obj = { key0: \u0026#34;aa\u0026#34;, key1: \u0026#34;bb\u0026#34; }; function changeObj(xyz){ console.log(xyz);\t// {key0: \u0026#39;aa\u0026#39;, key1: \u0026#39;bb\u0026#39;} \txyz = {key2:\u0026#34;cc\u0026#34;}; console.log(xyz);\t// {key2: \u0026#39;cc\u0026#39;} } // 以第三方函式傳值 changeObj(obj); // 但結果 obj 的值並未更動 console.log(obj);\t// {key0: \u0026#39;aa\u0026#39;, key1: \u0026#39;bb\u0026#39;}   在上面這個例子中，把 obj 傳入函式 changeObj(obj); 裡面，並對 obj 重新賦值。如果物件型別的值是「傳址」的話， obj 應該會被指向新的記憶體位置，且其值會變成 {key2: 'cc'}。\n但最後結果卻是 obj 並未被更動，仍維持舊值。\n這樣看來，物件型別的值在參數的傳遞上，既不是 pass by value 也不是 pass by reference。\n由於有這些奇怪的狀況，所以才有說法認為 Javascript 不是「傳值（by value）」，也不是「傳址（by reference）」而是「傳共享（pass by sharing）」。\n意思就是說，讓 function 裡面 xyz 跟外面的 obj 「共享」同一個 object，所以可以透過 function 裡面的 xyz 修改「共享到的那個 object」的資料。\n其實 Javascript 實際上就只有「傳值(by value)」 看到這個副標，你大概會想：「很好，現在又是甚麼狀況？」\n會產生這些眾說紛紜的說法，原因在於大家對於 Value 和 Reference 的定義不同。\n我們來回頭看看剛剛解釋「by reference」所使用的圖：\n 如果把記憶體位置 0x03 視作變數 obj 和 obj2 所儲存的值，那麼其實「pass by reference」也可以說是「pass by value」的一種，只是這個 value 是 reference 而已。\n關於這個問題的討論相當多而且複雜，以上只是我以自己所能理解的程度做的簡單整理。而對於 Javascript 究竟是「pass by sharing」還是只有「pass by value」，就留待諸君各自判斷了。\n 參考資料：\n 談談 JavaScript 中 by reference 和 by value 的重要觀念 重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？ JavaScript 的「傳值」與「傳址」 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ 理解 mutable VS immutable 物件 [JavaScript] Javascript中的傳值 by value 與傳址 by reference 林儀泰：簡單介紹JavaScript參數傳遞 I Want To Know JS系列 第 7 篇：JavaScript - 參數傳遞方式 (1) I Want To Know JS系列 第 8 篇：JavaScript - 參數傳遞方式 (2) 你不可不知的 JavaScript 二三事#Day26：程式界的哈姆雷特 —— Pass by value, or Pass by reference？ call by value 傳值 \u0026amp; call by reference 傳址   ","description":"Javascript 是「傳值」（call/pass by value）還是「傳址（也有譯為「傳參考」）」（call/pass by reference）？可說是 Javascript 的萬年爭議經典題目。究竟兩者定義為何？有甚麼差別？另外 call/pass by sharing（傳共享）又是甚麼呢？","id":1,"section":"posts","tags":["Javascript"],"title":"Javascript 的參數傳遞：by reference（傳址/傳參考）、by value（傳值）和 by sharing（傳共享）","uri":"https://sylvia-H.github.io/posts/2021/1013_byvalue_reference_sharing/"},{"content":"型別名詞釋義:\r靜態型別 動態型別 隱性型別 強型別 弱型別\r\r 在釐清 Javascript 的資料型別的過程中，一不小心踏入了這個名詞坑。\n一開始只是想釐清 Javascript 的資料型別，讀到 MDN 一篇關於 JavaScript 的資料型別與資料結構的文章，文中出現「動態型別」一詞來說明 Javascript 的特性，為了弄清楚該詞的意思，結果一腳踏入無底坑洞\u0026hellip;\n既然時間都花下去了，就來整理一下筆記吧。\n靜態型別、編譯式語言 靜態型別的語言(statically typed language)在型別的管理上十分嚴謹，在語法撰寫時就會要求對變數型別有明確定義。\n例如：\n1  int x;   宣告變數的時候就已經規定了未來存入的值是怎樣的資料型別，如果已經用 int 宣告了 x，就代表 x 將不能被放入字串資料，而只能放入整數。\n在變數宣告與初始化階段就把變數和型別進行靜態綁定，就稱之為 「靜態型別的語言」。\n編譯式語言多半會是靜態型別的語言，在編譯時期就會事先定義的型別，進行型別檢查，若出現變數誤用，資料型態不正確的話，在編譯時期就能發現，降低執行時期的風險。\nC、C++、Rust、Go、Visual Basic、Swift、Obj-C、Java 和 C# 就是屬於編譯式語言。\n而什麼是編譯式語言呢？\n也就是程式執行前先透過編譯器(compiler)將程式碼編譯後再執行的語言，就稱為編譯式語言(Compiled language)。過程如下：\n程式碼 \u0026mdash;\u0026gt; 編譯器(compiler) \u0026mdash;\u0026gt; 機器碼(machine language) 隱性型別(implicitly typed)的靜態語言 有些靜態語言在宣告時，也不需要指定型別，而是透過隱性推導的方式來確認型別。例如傳統 C# 宣告變數時需要指定型別：\n1  int x = 123;   但到了 C# 4.0 ，宣告變數就可以不用指定型別：\n1  var n = 456;   但是其型別就是初始值的型別，宣告時已經進行初始化，不能在中途任意改變型別，所以骨子裡還是靜態型別語言，稱為隱性型別(implicitly typed)的靜態語言。\n不同於隱性型別是透過編譯過程的推導而得知型別，顯性型別(explicitly typed)則是將型別作為語法宣告的一部份。\n動態型別、直譯式語言 動態型別的語言(dynamically typed language)相較於靜態型別的語言，在型別的處理上較鬆散靈活。\n以 Javascript 為例：\n1 2 3 4 5 6 7  let x; x=\u0026#34;Hello\u0026#34;; console.log(x); x=12; console.log(x);   宣告變數 x 時，沒有明確指定 x 的型別，代表能放入任意類型的資料；在賦值為 \u0026quot;Hello\u0026quot; 字串後，又改變賦值的資料型態放入整數 12，即便這樣改換資料型別，但程式依然可以成功運作。\n這表示動態型別的語言在程式執行過程才會進行資料型態的檢查或確認，到執行階段才能夠明確變數的型別，而且變數的型別隨時可以變化，因此直譯式語言(Interpreted language)都是動態型別語言。如 Python、PHP、Ruby、JavaScript，都屬於此類語言。\n直譯式語言在執行時，才會一行一行的動態將程式碼直譯(interpret)為機器碼並執行，因此速度上會比編譯式語言要慢。其緩慢的運行速度是直譯語言最大的壞處。\n動態/靜態/編譯/直譯，各型別差異 執行速度 v.s. 開發速度 雖然就執行時期的執行速度而言，編譯語言會比直譯語言來得快；然而，編譯語言的壞處是編譯時期的程式開發和除錯速度比較慢，不能像直譯語言一樣，開發一小段程序便立刻運行。\n執行環境 編譯語言由編譯器進行型別和語意檢查後，編譯完成的執行檔是可以獨立運行的，程式碼能直接存取系統服務 (system service) 與 APIs，因此執行效率特別好。\n但直譯語言則必須依賴一個執行環境 (execution context)才可以執行。\n例如 JavaScript 只能使用瀏覽器提供的功能，它無法獨立執行 (看起來像獨立執行，實際上卻是系統自動在背後建立執行環境，如 HTML Application)；或是像 Python3 程式碼需要有在有安裝 Python3 的電腦中才可以運行。\n即時編譯 編譯語言開發與除錯速度慢，而直譯語言執行速度慢，若能同時改善兩者缺點、取其優點，豈不理想？！\n思及此，因而發展出即時編譯的技術。這種技術混合了編譯語言與直譯語言的優點，如同編譯語言，會先把程式原始碼編譯成中介碼 (Bytecode)。到執行期時，再將中介碼直譯之後執行。\n使用即時編譯技術的語言會比純編譯語言來的慢一些，但是卻又擁有直譯語言的特性。Java、C# 就是其中代表。\n強型別、弱型別 靜態型別、動態型別指的是變數與型別的綁定方法。\n強型別、弱型別 則是 執行階段時，型別轉換的容許程度；也可以說是語言型別系統(Type System)的編譯器或直譯器對型別檢查的寬容程度、嚴格程度、型別安全的程度。\n強型別指的是「程式所定義的變數型別等於變數在執行時期的型別」。\n例如，Java 為例，企圖在數字運算過程混進一個字串：\n1  int x = 123 + \u0026#34;456\u0026#34;;   就會產生編譯錯誤，這就是屬於強型別。\n但如果是 PHP 的話：\n1 2  $x = 123 + \u0026#34;456\u0026#34;; echo $x;   字串與數字相加的執行結果會出現 579，是可以運行成功的。表示 PHP 的直譯器能夠容忍隱性的型別轉換，也就弱型別。\n雖然常看到的靜態語言大部分是強型別。但這並不代表靜態語言一定是強型別、動態語言一定是弱型別。例如：Python 雖然是動態語言，但在型別判斷的嚴格程度上，Python 是一個強型別。\n常見語言的型別特性 這個部份真的要大推 2019 iT 邦幫忙鐵人賽的你不可不知的 JavaScript 二三事系列 Day3，該文將動態靜態強弱型別整理得非常清楚！\n以下也是把該文的整理結果擷取過來。\n幾種常見程式語言的型別特性：\n   靜態語言／動態語言 強型別／弱型別 程式語言     靜態 強 Java, C#   靜態 弱 C/C++   動態 強 Python, Ruby   動態 弱 Perl, PHP, JavaScript    靜態語言又分顯性型別和隱性型別：\n靜態顯性型別：Java, C\n靜態隱性型別：Ocaml, Haskell\n各語言所處的型別象限：\n由以上的象限圖可以看出作為動態網頁不可缺少的角色 \u0026mdash; Javascript，所處的位置是動態型別，而且是比 PHP 還要弱的弱型別。（哭哭）\n原因在於 Javascript 在處理數學運算和字串串接的時候，算數運算子和串接運算子都是「+」，這就是為什麼 JavaScript 常常容易出現一些意想不到的相加結果。雖然 PHP 是屬於弱型別，對不同型別也會做出隱式轉換，但 PHP 進行字串串接的時候會使用「.」作為串接運算子，在數學運算和字串串接上稍稍有所區隔，因此弱型別的程度沒有 Javascript 嚴重。這部分的討論可以參考這邊。\n 參考資料：\n MDN　|　JavaScript 的資料型別與資料結構 維基百科 - 強弱型別 Day 2：資料型態的夢魘——動態型別加弱型別(1) Day 3：資料型態的夢魘——動態型別加弱型別(2) Day 4：動態型別加弱型別不是罪——怎麼 JavaScript 一摔就變成個印度阿三？ 淺談程式語言型別的強型別，弱型別，動態型別，靜態型別 編譯語言 VS 直譯語言 動態型別語言\u0026amp;動態語言 淺談程式語言型別的強型別，弱型別，動態型別，靜態型別 重新認識 JavaScript: Day 03 變數與資料型別   ","description":"編譯式語言和直譯式語言牽涉到許多個關於「型別」的名詞，一下子讓人墜入五里霧中，這篇筆記把我所看到的資料進行整理，將這些名詞的定義與關聯性做個簡單的報告。","id":2,"section":"posts","tags":["Javascript"],"title":"型別名詞釋義：靜態型別/動態型別/隱性型別/強型別/弱型別","uri":"https://sylvia-H.github.io/posts/2021/0919_language-type/"}]