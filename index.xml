<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Sylvia&#39;s Babel</title>
    <link>https://sylvia-h.github.io/</link>
    <description>Recent content on Sylvia&#39;s Babel</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>sylvie11gaia@gmail.com (Sylvia-H)</managingEditor>
    <webMaster>sylvie11gaia@gmail.com (Sylvia-H)</webMaster>
    <copyright>©2021, All Rights Reserved</copyright>
    <lastBuildDate>Sat, 06 Nov 2021 19:35:00 +0800</lastBuildDate>
    
        <atom:link href="https://sylvia-h.github.io/index.xml" rel="self" type="application/rss+xml" />
    
      
      
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      

      
      <item>
        <title>【釋疑筆記】indexOf() 和 lastIndexOf() 的差別</title>
        <link>https://sylvia-h.github.io/posts/2021/1106_indexof_lastindexof/</link>
        <pubDate>Sat, 06 Nov 2021 19:35:00 +0800</pubDate>
        <author>sylvie11gaia@gmail.com (Sylvia-H)</author>
        <atom:modified>Sat, 06 Nov 2021 19:35:00 +0800</atom:modified>
        <guid>https://sylvia-h.github.io/posts/2021/1106_indexof_lastindexof/</guid>
        <description>indexOf() 和 lastIndexOf() 的差別在哪裡？其中參數所代表的意義為何？
本來以為查了 MDN 就能明白，結果越看越不懂，動手用 console.log 試了幾遍才終於理解。於是把自己的理解重新整理成下面的筆記。
MDN | indexOf 語法與參數涵義 arr.indexOf(searchElement[, fromIndex]) indexOf(尋找某元素, 從哪裡開始找到最後) = 第一個找到的索引值
MDN | lastIndexOf 語法與參數涵義 arr.lastIndexOf(searchElement, fromIndex) lastIndexOf(尋找某元素, 從 0 開始找到哪裡) = 最後一個找到的索引值
範例 1 2 3 4 5 6 7  arr = [0,1,2,1,0,2,1] arr.indexOf(1,4);	// 6 arr.indexOf(1,2);	// 3  arr.lastIndexOf(1,4);	// 3 arr.lastIndexOf(1,2);	// 1   結論 lastIndexOf (a, b) 會從 0 一直找到陣列的 b位置，回傳最後一個被找到的索引值。找不到的話，回傳 -1。
indexOf (a, b) 會從陣列b位置開始找到陣列最後，回傳第一個被找到的索引值。找不到的話，回傳 -1。
 延伸閱讀：
 MDN | Array.prototype.indexOf() MDN | Array.prototype.lastIndexOf()   </description>
        
        <dc:creator>Sylvia-H</dc:creator>
        <media:content url="https://sylvia-h.github.ioimages/posts/js/js.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>Javascript</category>
            
          
        
        
          
            
              <category>JS 釋疑筆記</category>
            
          
        
        
      </item>
      
      <item>
        <title>【JS30系列】Day 05：Flex Panels Gallery</title>
        <link>https://sylvia-h.github.io/posts/2021/javascript30_day05/</link>
        <pubDate>Fri, 29 Oct 2021 18:16:00 +0800</pubDate>
        <author>sylvie11gaia@gmail.com (Sylvia-H)</author>
        <atom:modified>Fri, 29 Oct 2021 18:16:00 +0800</atom:modified>
        <guid>https://sylvia-h.github.io/posts/2021/javascript30_day05/</guid>
        <description>Javascript 30 Day05:Flex Panels Gallery Wes Bos 的原始專案：JS30 Day05  Wes Bos 教學影片 Day 05 Day 05 專案完成前 Day 05 專案完成後  專案目標： 運用 flex 以及綁定 click 和 transitionend 監聽事件來呈現畫廊效果。
點擊後相應的圖片與字體會放大，再次點擊則回復原狀。
實作成果
步驟一：CSS 添加 flex 等等屬性 在正式寫 js 之前，首先先對 CSS 做一些修改。
由於一開始的專案畫面，五張圖片是平行呈現，為了呈現最終畫面的效果，首先在 .panels 增加 flex 屬性。
1 2 3 4  .panels { /* 以下為新增屬性 */ display: flex; }   接下來針對 .panels 類別底下的 .panel類別。因為要平均分配每張圖片的呈現空間，所以添加 flex: 1;。
.panel 類別底下的三個 &amp;lt;p&amp;gt; 段落需要由上而下平行呈現，所以添加了 flex-direction: column;。
.panel &amp;gt; * 類別也做出相應調整。
1 2 3 4 5 6 7 8 9 10 11 12 13 14  .panel { /* 以下為新增屬性 */ flex: 1; display: flex; flex-direction: column; } .</description>
        
        <dc:creator>Sylvia-H</dc:creator>
        <media:content url="https://sylvia-h.github.ioimages/posts/js30/js30.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>JS30</category>
            
          
            
              <category>Javascript</category>
            
          
        
        
          
            
              <category>JS30 系列</category>
            
          
        
        
          
            
              <category>JS30 系列學習筆記</category>
            
          
        
      </item>
      
      <item>
        <title>【JS30系列】Day 04：Array Cardio Day 1</title>
        <link>https://sylvia-h.github.io/posts/2021/javascript30_day04/</link>
        <pubDate>Thu, 28 Oct 2021 21:42:11 +0800</pubDate>
        <author>sylvie11gaia@gmail.com (Sylvia-H)</author>
        <atom:modified>Thu, 28 Oct 2021 21:42:11 +0800</atom:modified>
        <guid>https://sylvia-h.github.io/posts/2021/javascript30_day04/</guid>
        <description>Wes Bos 的原始專案：JS30 Day04  Wes Bos 教學影片 Day 04 Day 04 專案完成前 Day 04 專案完成後  專案目標： 熟悉陣列操作方法：filter()、map()、sort()、reduce()、from()、includes()、slice()。
此範例瀏覽器不會渲染出畫面，純粹用陣列操作方法來篩選出資料。
實作成果
資料集 題目給了兩筆資料集，以下共有 8 道題目要從以下兩個資料集中篩選出目標物件資料。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const inventors = [ { first: &amp;#39;Albert&amp;#39;, last: &amp;#39;Einstein&amp;#39;, year: 1879, passed: 1955 }, { first: &amp;#39;Isaac&amp;#39;, last: &amp;#39;Newton&amp;#39;, year: 1643, passed: 1727 }, { first: &amp;#39;Galileo&amp;#39;, last: &amp;#39;Galilei&amp;#39;, year: 1564, passed: 1642 }, { first: &amp;#39;Marie&amp;#39;, last: &amp;#39;Curie&amp;#39;, year: 1867, passed: 1934 }, { first: &amp;#39;Johannes&amp;#39;, last: &amp;#39;Kepler&amp;#39;, year: 1571, passed: 1630 }, { first: &amp;#39;Nicolaus&amp;#39;, last: &amp;#39;Copernicus&amp;#39;, year: 1473, passed: 1543 }, { first: &amp;#39;Max&amp;#39;, last: &amp;#39;Planck&amp;#39;, year: 1858, passed: 1947 }, { first: &amp;#39;Katherine&amp;#39;, last: &amp;#39;Blodgett&amp;#39;, year: 1898, passed: 1979 }, { first: &amp;#39;Ada&amp;#39;, last: &amp;#39;Lovelace&amp;#39;, year: 1815, passed: 1852 }, { first: &amp;#39;Sarah E.</description>
        
        <dc:creator>Sylvia-H</dc:creator>
        <media:content url="https://sylvia-h.github.ioimages/posts/js30/js30.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>JS30</category>
            
          
            
              <category>Javascript</category>
            
          
        
        
          
            
              <category>JS30 系列</category>
            
          
        
        
          
            
              <category>JS30 系列學習筆記</category>
            
          
        
      </item>
      
      <item>
        <title>【JS30系列】Day 03：CSS Variables</title>
        <link>https://sylvia-h.github.io/posts/2021/javascript30_day03/</link>
        <pubDate>Thu, 21 Oct 2021 16:43:11 +0800</pubDate>
        <author>sylvie11gaia@gmail.com (Sylvia-H)</author>
        <atom:modified>Thu, 21 Oct 2021 16:43:11 +0800</atom:modified>
        <guid>https://sylvia-h.github.io/posts/2021/javascript30_day03/</guid>
        <description>Javascript 30 Day03:CSS Variables Wes Bos 的原始專案：JS30 Day03  Wes Bos 教學影片 Day 03 Day 03 專案完成前 Day 03 專案完成後  專案目標： 利用控制條來調整圖片邊框粗細、邊框色彩以及模糊程度的濾鏡效果。
我的解法： 實作成果
1 2 3 4 5 6 7 8 9 10 11  const image = document.querySelector(&amp;#34;img&amp;#34;); function getValue(){ let spacing = document.getElementById(&amp;#34;spacing&amp;#34;).value; let blur = document.getElementById(&amp;#34;blur&amp;#34;).value; let baseColor = document.getElementById(&amp;#34;base&amp;#34;).value; image.style.border = `${spacing}px solid ${baseColor}`; image.style.filter = `blur(${blur}px)`; } document.addEventListener(&amp;#39;mousemove&amp;#39;, getValue);   我的解法比較簡單粗暴一點，主要是用 getElementById 取得元素的值，然後綁定 mousemove 事件監聽。再用 .style 和樣板字面值來修改元素的 class 屬性。
Wes Bos 的解法： Wes Bos 的解法則有意思得多。
首先是在 CSS 中用了我不太熟悉的 :root 根目錄選取器，同時也是這個範例的核心主題，但我一開始解的時候完全沒有注意到，就直接用自己熟悉的方式來解。等解完再回頭看 Wes Bos 的寫法，才發現到這個主題有使用 :root 根目錄選取器。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  :root { --base: #ffc600; --spacing: 10px; --blur: 10px; } img { padding: var(--spacing); background: var(--base); filter: blur(var(--blur)); } .</description>
        
        <dc:creator>Sylvia-H</dc:creator>
        <media:content url="https://sylvia-h.github.ioimages/posts/js30/js30.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>JS30</category>
            
          
            
              <category>Javascript</category>
            
          
        
        
          
            
              <category>JS30 系列</category>
            
          
        
        
          
            
              <category>JS30 系列學習筆記</category>
            
          
        
      </item>
      
      <item>
        <title>【JS30系列】Day 02：CSS &#43; JS Clock</title>
        <link>https://sylvia-h.github.io/posts/2021/javascript30_day02/</link>
        <pubDate>Wed, 20 Oct 2021 20:35:11 +0800</pubDate>
        <author>sylvie11gaia@gmail.com (Sylvia-H)</author>
        <atom:modified>Wed, 20 Oct 2021 20:35:11 +0800</atom:modified>
        <guid>https://sylvia-h.github.io/posts/2021/javascript30_day02/</guid>
        <description>Javascript 30 Day02:CSS &amp;#43; JS Clock Wes Bos 的原始專案：JS30 Day02  Wes Bos 教學影片 Day 02 Day 02 專案完成前 Day 02 專案完成後  專案目標： 製作一個時、分、秒針能實時運轉的小時鐘。
我的解法： 實作成果
1 2 3 4 5 6 7 8 9  .hand { width: 0; height: 0; position: absolute; top: 50%; border-style: solid; border-width: 3px 15rem 3px 0; transform-origin: 100%; }   
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  const hourHand = document.querySelector(&amp;#39;.hour-hand&amp;#39;); const minHand = document.querySelector(&amp;#39;.min-hand&amp;#39;); const secondHand = document.</description>
        
        <dc:creator>Sylvia-H</dc:creator>
        <media:content url="https://sylvia-h.github.ioimages/posts/js30/js30.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>JS30</category>
            
          
            
              <category>Javascript</category>
            
          
        
        
          
            
              <category>JS30 系列</category>
            
          
        
        
          
            
              <category>JS30 系列學習筆記</category>
            
          
        
      </item>
      
      <item>
        <title>【JS30系列】Day 01：JavaScript Drum Kit</title>
        <link>https://sylvia-h.github.io/posts/2021/javascript30_day01/</link>
        <pubDate>Tue, 19 Oct 2021 17:56:11 +0800</pubDate>
        <author>sylvie11gaia@gmail.com (Sylvia-H)</author>
        <atom:modified>Tue, 19 Oct 2021 17:56:11 +0800</atom:modified>
        <guid>https://sylvia-h.github.io/posts/2021/javascript30_day01/</guid>
        <description>Javascript 30 Day01:JavaScript Drum Kit Wes Bos 的原始專案：JS30 Day01  Wes Bos 教學影片 Day 01 Day 01 專案完成前 Day 01 專案完成後  專案目標：  按下與畫面上對應的鍵盤按鍵時，相應的方框會稍微放大字體 外框會發出黃色光暈 同時撥放音檔  我的解法： 實作成果
1 2 3 4 5 6 7 8 9 10 11 12 13 14  document.addEventListener(&amp;#39;keydown&amp;#39;, pressKey); document.addEventListener(&amp;#39;keyup&amp;#39;, upKey); function pressKey(e) { keyElement = document.querySelector(`.key[data-key=&amp;#34;${e.keyCode}&amp;#34;]`); keyElement.classList.add(&amp;#39;playing&amp;#39;); audioElement = document.querySelector(`audio[data-key=&amp;#34;${e.keyCode}&amp;#34;]`); audioElement.play(); } function upKey(e) { keyElement = document.querySelector(`.key[data-key=&amp;#34;${e.keyCode}&amp;#34;]`); keyElement.classList.remove(&amp;#39;playing&amp;#39;); }   
觀念一：鍵盤事件 KeyBoard Event KeyCode 對照表
 e.keyCode：綁定「按下鍵盤按鍵（keydown &amp;amp; keypress）」、「放開鍵盤按鍵（keyup）」等事件監聽，可以獲取按下的鍵盤按鍵的 Unicode 值。 keydown：按下鍵盤（任何的鍵盤按鍵）的那個剎那會觸發此事件 keypress：按下鍵盤（可以輸出文字符號的按鍵）的那個剎那會觸發此事件 keyup：放開鍵盤的那個剎那，會觸發此事件   延伸閱讀：
 鍵盤事件keypress 和 keydown、keyup 的用法與區別 比較 keydown, keypress, keyup 的差異   觀念二：data-取值  用 getAttribute() 方法取得 DOM 元素的 data- 屬性  1  &amp;lt;div id=&amp;#34;myDiv&amp;#34; data-appid=&amp;#34;123&amp;#34; data-myname=&amp;#34;Sylvia&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;   1 2 3  let dataDiv = document.</description>
        
        <dc:creator>Sylvia-H</dc:creator>
        <media:content url="https://sylvia-h.github.ioimages/posts/js30/js30.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>JS30</category>
            
          
            
              <category>Javascript</category>
            
          
        
        
          
            
              <category>JS30 系列</category>
            
          
        
        
          
            
              <category>JS30 系列學習筆記</category>
            
          
        
      </item>
      
      <item>
        <title>Javascript 的參數傳遞：by reference（傳址/傳參考）、by value（傳值）和 by sharing（傳共享）</title>
        <link>https://sylvia-h.github.io/posts/2021/1013_byvalue_reference_sharing/</link>
        <pubDate>Wed, 13 Oct 2021 15:48:11 +0800</pubDate>
        <author>sylvie11gaia@gmail.com (Sylvia-H)</author>
        <atom:modified>Wed, 13 Oct 2021 15:48:11 +0800</atom:modified>
        <guid>https://sylvia-h.github.io/posts/2021/1013_byvalue_reference_sharing/</guid>
        <description>Javascript 的參數傳遞:by reference (傳址/傳參考)、by value（傳值）和 by sharing（傳共享） 從比較運算子來釐清基本觀念 在正式進入這個主題之前，我們先來複習一下 JavaScript 的基本觀念。首先是「比較運算子」：
1 2 3  let a = 3; let b = 3; console.log(a === b);   上面這題印出的答案是甚麼呢？沒錯，是 true。
看到這邊，你可能會想翻桌，這麼簡單的問題還要問嗎？值與型別都相同，用嚴格相等比較運算子（===），結果當然是 true 啊。
先壓壓怒氣，再來看看下面這題：
1 2 3  let c = [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;]; let d = [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;]; console.log(c === d);   「廢話，當然也是 true 啊！」
你確定嗎？
那麼下面這幾題呢？
1 2 3 4  console.log( [] === [] ); console.log( [1] === [1] ); console.log( {} === {} ); console.log( {a:1} === {a:1} );   執行以上五個判斷式的結果是什麼呢？
結果竟然全部是 false ！
原因就在於 Javascript 中不同型別的變數會有不同的儲存和傳遞資料的方式，大致上可以分為 「傳值」(call/pass by value) 和 「傳址（也有譯為「傳參考」）」(call/pass by reference) 兩種。</description>
        
        <dc:creator>Sylvia-H</dc:creator>
        <media:content url="https://sylvia-h.github.ioimages/posts/js/2021-10-13/passByValue_byReference_bySharing.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>Javascript</category>
            
          
        
        
          
            
              <category>JS 基礎觀念</category>
            
          
        
        
      </item>
      
      <item>
        <title>型別名詞釋義：靜態型別/動態型別/隱性型別/強型別/弱型別</title>
        <link>https://sylvia-h.github.io/posts/2021/0919_language-type/</link>
        <pubDate>Sun, 19 Sep 2021 20:17:11 +0800</pubDate>
        <author>sylvie11gaia@gmail.com (Sylvia-H)</author>
        <atom:modified>Sun, 19 Sep 2021 20:17:11 +0800</atom:modified>
        <guid>https://sylvia-h.github.io/posts/2021/0919_language-type/</guid>
        <description>型別名詞釋義:靜態型別 動態型別 隱性型別 強型別 弱型別 在釐清 Javascript 的資料型別的過程中，一不小心踏入了這個名詞坑。
一開始只是想釐清 Javascript 的資料型別，讀到 MDN 一篇關於 JavaScript 的資料型別與資料結構的文章，文中出現「動態型別」一詞來說明 Javascript 的特性，為了弄清楚該詞的意思，結果一腳踏入無底坑洞&amp;hellip;
既然時間都花下去了，就來整理一下筆記吧。
靜態型別、編譯式語言 靜態型別的語言(statically typed language)在型別的管理上十分嚴謹，在語法撰寫時就會要求對變數型別有明確定義。
例如：
1  int x;   宣告變數的時候就已經規定了未來存入的值是怎樣的資料型別，如果已經用 int 宣告了 x，就代表 x 將不能被放入字串資料，而只能放入整數。
在變數宣告與初始化階段就把變數和型別進行靜態綁定，就稱之為 「靜態型別的語言」。
編譯式語言多半會是靜態型別的語言，在編譯時期就會事先定義的型別，進行型別檢查，若出現變數誤用，資料型態不正確的話，在編譯時期就能發現，降低執行時期的風險。
C、C++、Rust、Go、Visual Basic、Swift、Obj-C、Java 和 C# 就是屬於編譯式語言。
而什麼是編譯式語言呢？
也就是程式執行前先透過編譯器(compiler)將程式碼編譯後再執行的語言，就稱為編譯式語言(Compiled language)。過程如下：
程式碼 &amp;mdash;&amp;gt; 編譯器(compiler) &amp;mdash;&amp;gt; 機器碼(machine language) 隱性型別(implicitly typed)的靜態語言 有些靜態語言在宣告時，也不需要指定型別，而是透過隱性推導的方式來確認型別。例如傳統 C# 宣告變數時需要指定型別：
1  int x = 123;   但到了 C# 4.0 ，宣告變數就可以不用指定型別：
1  var n = 456;   但是其型別就是初始值的型別，宣告時已經進行初始化，不能在中途任意改變型別，所以骨子裡還是靜態型別語言，稱為隱性型別(implicitly typed)的靜態語言。
不同於隱性型別是透過編譯過程的推導而得知型別，顯性型別(explicitly typed)則是將型別作為語法宣告的一部份。
動態型別、直譯式語言 動態型別的語言(dynamically typed language)相較於靜態型別的語言，在型別的處理上較鬆散靈活。
以 Javascript 為例：
1 2 3 4 5 6 7  let x; x=&amp;#34;Hello&amp;#34;; console.</description>
        
        <dc:creator>Sylvia-H</dc:creator>
        <media:content url="https://sylvia-h.github.ioimages/posts/js/2021-09-19/type_paraphrase.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>Javascript</category>
            
          
        
        
          
            
              <category>JS 基礎觀念</category>
            
          
        
        
      </item>
      

    
  </channel>
</rss>
