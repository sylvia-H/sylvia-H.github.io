[{"content":"indexOf() 和 lastIndexOf() 的差別在哪裡？其中參數所代表的意義為何？\n本來以為查了 MDN 就能明白，結果越看越不懂，動手用 console.log 試了幾遍才終於理解。於是把自己的理解重新整理成下面的筆記。\nMDN | indexOf 語法與參數涵義 arr.indexOf(searchElement[, fromIndex]) indexOf(尋找某元素, 從哪裡開始找到最後) = 第一個找到的索引值\nMDN | lastIndexOf 語法與參數涵義 arr.lastIndexOf(searchElement, fromIndex) lastIndexOf(尋找某元素, 從 0 開始找到哪裡) = 最後一個找到的索引值\n範例 1 2 3 4 5 6 7  arr = [0,1,2,1,0,2,1] arr.indexOf(1,4);\t// 6 arr.indexOf(1,2);\t// 3  arr.lastIndexOf(1,4);\t// 3 arr.lastIndexOf(1,2);\t// 1   結論 lastIndexOf (a, b) 會從 0 一直找到陣列的 b位置，回傳最後一個被找到的索引值。\nindexOf (a, b) 會從陣列b位置開始找到陣列最後，回傳第一個被找到的索引值。\n 延伸閱讀：\n MDN | Array.prototype.indexOf() MDN | Array.prototype.lastIndexOf()   ","description":"indexOf() 和 lastIndexOf() 的差別在哪裡？其中的參數所代表的意義為何？看 MDN 的解釋還是覺得有點模糊不清，所以把自己的理解重新整理成一份筆記。","id":0,"section":"posts","tags":["Javascript"],"title":"【釋疑筆記】indexOf() 和 lastIndexOf() 的差別","uri":"https://sylvia-h.github.io/posts/2021/1106_indexof_lastindexof/"},{"content":"Javascript 30 Day05:\rFlex Panels Gallery\r\r Wes Bos 的原始專案：JS30 Day05  Wes Bos 教學影片 Day 05 Day 05 專案完成前 Day 05 專案完成後  專案目標： 運用 flex 以及綁定 click 和 transitionend 監聽事件來呈現畫廊效果。\n點擊後相應的圖片與字體會放大，再次點擊則回復原狀。\n實作成果\n步驟一：CSS 添加 flex 等等屬性 在正式寫 js 之前，首先先對 CSS 做一些修改。\n由於一開始的專案畫面，五張圖片是平行呈現，為了呈現最終畫面的效果，首先在 .panels 增加 flex 屬性。\n1 2 3 4  .panels { /* 以下為新增屬性 */ display: flex; }   接下來針對 .panels 類別底下的 .panel類別。因為要平均分配每張圖片的呈現空間，所以添加 flex: 1;。\n.panel 類別底下的三個 \u0026lt;p\u0026gt; 段落需要由上而下平行呈現，所以添加了 flex-direction: column;。\n.panel \u0026gt; * 類別也做出相應調整。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  .panel { /* 以下為新增屬性 */ flex: 1; display: flex; flex-direction: column; } .panel \u0026gt; * { /* 以下為新增屬性 */ flex: 1; display: flex; justify-content: center; align-items: center; }   以上這些基本修改完成後，接下來是針對畫面點擊效果。\n設計在 .panel 上添加 .open，並於完成 transition 動畫特效後，再添加 .open-end 的第二次特效。\n1 2 3 4 5 6 7 8 9 10 11  .panel.open { font-size: 40px; /* 以下為新增屬性 */ flex: 5; } /* 以下為新增屬性 */ .panel \u0026gt; *:first-child{transform: translateY(-100%);} .panel.open-end \u0026gt; *:first-child{transform: translateY(-0%);} .panel \u0026gt; *:last-child{transform: translateY(100%);} .panel.open-end \u0026gt; *:last-child{transform: translateY(-0%);}   圖片被點擊後，圖片所占空間會變大，字體也會變大，所以 .panel.open 中更改了 font-size 字體大小，且將 flex 設為 5。\n由於初始專案在 .panel 中有設定 transition，所以會針對字體大小和圖片空間產生動畫特效。\n1 2 3 4  transition: font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11), flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11), background 0.2s;   \n步驟二：為 panel 綁定事件監聽 CSS 的部分都修改好後，就正式進入 js 的部分。\n主要就是用 querySelectorAll 撈出所有 .panel 的 DOM 元素，並在上面綁定兩個事件監聽。\n第一個是 addEventListener('click', openPanel)。在點擊的時候為 .panel 添加上 .open 類別，做出圖片空間變大以及字體變大的特效。\n第二個是 addEventListener('transitionend', openEnd)。這個事件監聽是在完成 .open 特效後才發生，因此使用 transitionend 事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const panels = document.querySelectorAll(\u0026#34;.panel\u0026#34;); function openPanel(){ this.classList.toggle(\u0026#39;open\u0026#39;); } function openEnd(e){ // this.classList.toggle(\u0026#39;open-end\u0026#39;);  if (e.propertyName.includes(\u0026#39;font-size\u0026#39;)) { this.classList.toggle(\u0026#39;open-end\u0026#39;); } } panels.forEach(el =\u0026gt; el.addEventListener(\u0026#39;click\u0026#39;, openPanel)); panels.forEach(el =\u0026gt; el.addEventListener(\u0026#39;transitionend\u0026#39;, openEnd));   \n比較特別的是，因為 .open 觸發了兩次的 transition 第一次是 font-size: 40px;，第二次是 flex: 5;，所以我們所添加的 transitionend 事件監聽也會觸發兩次，故 toggle('open-end') 發生兩次後，變成 .open-end 類別沒有被成功添加上去。\n所以這裡必須再加入一個判斷式，判斷所點擊的對象是否有內含屬性 font-size: 40px; 或 flex: 5;。\nWes Bos 的判斷式是寫 e.propertyName.includes('flex')，這裡寫 e.propertyName.includes('font-size') 也是一樣的。\n 延伸閱讀：\n MDN | Flex MDN | transitionend   ","description":"運用 flex 以及綁定 click 和 transitionend 監聽事件來呈現畫廊效果。點擊後相應的圖片與字體會放大，再次點擊則回復原狀。","id":1,"section":"posts","tags":["JS30","Javascript"],"title":"【JS30系列】Day 05：Flex Panels Gallery","uri":"https://sylvia-h.github.io/posts/2021/javascript30_day05/"},{"content":"Wes Bos 的原始專案：JS30 Day04  Wes Bos 教學影片 Day 04 Day 04 專案完成前 Day 04 專案完成後  專案目標： 熟悉陣列操作方法：filter()、map()、sort()、reduce()、from()、includes()、slice()。\n此範例瀏覽器不會渲染出畫面，純粹用陣列操作方法來篩選出資料。\n實作成果\n資料集 題目給了兩筆資料集，以下共有 8 道題目要從以下兩個資料集中篩選出目標物件資料。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const inventors = [ { first: \u0026#39;Albert\u0026#39;, last: \u0026#39;Einstein\u0026#39;, year: 1879, passed: 1955 }, { first: \u0026#39;Isaac\u0026#39;, last: \u0026#39;Newton\u0026#39;, year: 1643, passed: 1727 }, { first: \u0026#39;Galileo\u0026#39;, last: \u0026#39;Galilei\u0026#39;, year: 1564, passed: 1642 }, { first: \u0026#39;Marie\u0026#39;, last: \u0026#39;Curie\u0026#39;, year: 1867, passed: 1934 }, { first: \u0026#39;Johannes\u0026#39;, last: \u0026#39;Kepler\u0026#39;, year: 1571, passed: 1630 }, { first: \u0026#39;Nicolaus\u0026#39;, last: \u0026#39;Copernicus\u0026#39;, year: 1473, passed: 1543 }, { first: \u0026#39;Max\u0026#39;, last: \u0026#39;Planck\u0026#39;, year: 1858, passed: 1947 }, { first: \u0026#39;Katherine\u0026#39;, last: \u0026#39;Blodgett\u0026#39;, year: 1898, passed: 1979 }, { first: \u0026#39;Ada\u0026#39;, last: \u0026#39;Lovelace\u0026#39;, year: 1815, passed: 1852 }, { first: \u0026#39;Sarah E.\u0026#39;, last: \u0026#39;Goode\u0026#39;, year: 1855, passed: 1905 }, { first: \u0026#39;Lise\u0026#39;, last: \u0026#39;Meitner\u0026#39;, year: 1878, passed: 1968 }, { first: \u0026#39;Hanna\u0026#39;, last: \u0026#39;Hammarström\u0026#39;, year: 1829, passed: 1909 } ]; const people = [ \u0026#39;Bernhard, Sandra\u0026#39;, \u0026#39;Bethea, Erin\u0026#39;, \u0026#39;Becker, Carl\u0026#39;, \u0026#39;Bentsen, Lloyd\u0026#39;, \u0026#39;Beckett, Samuel\u0026#39;, \u0026#39;Blake, William\u0026#39;, \u0026#39;Berger, Ric\u0026#39;, \u0026#39;Beddoes, Mick\u0026#39;, \u0026#39;Beethoven, Ludwig\u0026#39;, \u0026#39;Belloc, Hilaire\u0026#39;, \u0026#39;Begin, Menachem\u0026#39;, \u0026#39;Bellow, Saul\u0026#39;, \u0026#39;Benchley, Robert\u0026#39;, \u0026#39;Blair, Robert\u0026#39;, \u0026#39;Benenson, Peter\u0026#39;, \u0026#39;Benjamin, Walter\u0026#39;, \u0026#39;Berlin, Irving\u0026#39;, \u0026#39;Benn, Tony\u0026#39;, \u0026#39;Benson, Leana\u0026#39;, \u0026#39;Bent, Silas\u0026#39;, \u0026#39;Berle, Milton\u0026#39;, \u0026#39;Berry, Halle\u0026#39;, \u0026#39;Biko, Steve\u0026#39;, \u0026#39;Beck, Glenn\u0026#39;, \u0026#39;Bergman, Ingmar\u0026#39;, \u0026#39;Black, Elk\u0026#39;, \u0026#39;Berio, Luciano\u0026#39;, \u0026#39;Berne, Eric\u0026#39;, \u0026#39;Berra, Yogi\u0026#39;, \u0026#39;Berry, Wendell\u0026#39;, \u0026#39;Bevan, Aneurin\u0026#39;, \u0026#39;Ben-Gurion, David\u0026#39;, \u0026#39;Bevel, Ken\u0026#39;, \u0026#39;Biden, Joseph\u0026#39;, \u0026#39;Bennington, Chester\u0026#39;, \u0026#39;Bierce, Ambrose\u0026#39;, \u0026#39;Billings, Josh\u0026#39;, \u0026#39;Birrell, Augustine\u0026#39;, \u0026#39;Blair, Tony\u0026#39;, \u0026#39;Beecher, Henry\u0026#39;, \u0026#39;Biondo, Frank\u0026#39; ];   \n第一題：篩選出生在 1500 年代的發明家 本題要從 inventors 資料集篩選出生在 1500 年代的發明家。\nfilter() 方法，會將陣列中的「每一個元素」帶入指定的函式內做判斷，透過 return 回傳判斷結果為 true 的元素，並組成新的陣列。\n裡頭有一個函式 ( 必填 ) 和一個回傳函式裡的 this 參數 ( 選填 )。\n函式內包含三個參數，第一個是每個元素的值 ( 必填 )，第二個是當前元素的索引值 ( 選填 )，第三個是當前的陣列 ( 選填 )。\nfilter 語法：\nlet newArray = arr.filter(callback(element, index, array), thisArg); 本題解法 1 2 3 4 5 6 7  // Array.prototype.filter() // 1. Filter the list of inventors for those who were born in the 1500\u0026#39;s  let inventors_1500s = inventors.filter(el =\u0026gt; { return el.year\u0026lt;1600 \u0026amp;\u0026amp; el.year\u0026gt;1500; }); console.log(inventors_1500s);   \n第二題：將發明家的姓氏、名字組合起來，回傳一個新陣列 map() 方法，會將陣列中的「每一個元素」帶入指定的函式內做判斷，透過 return 回傳運算後的結果，並組成新的陣列。\n裡頭有一個函式 ( 必填 ) 和一個回傳函式裡的 this 參數 ( 選填 )。\n函式內包含三個參數，第一個是每個元素的值 ( 必填 )，第二個是當前元素的索引值 ( 選填 )，第三個是當前的陣列 ( 選填 )。\nmap 語法：\nlet new_array = arr.map(callback(currentValue, index, array));\n如果要使用 this 參數，則「不能使用」箭頭函式：\nlet new_array = arr.map(function callback(currentValue, index, array){}, thisArg);\n 本題解法 1 2 3 4 5 6 7  // Array.prototype.map() // 2. Give us an array of the inventors first and last names  let inventors_name = inventors.map(el =\u0026gt; { return el.first+\u0026#39; \u0026#39;+el.last; }); console.log(inventors_name);   \n第三題：將發明家的生日由老到少排序 sort() 方法，會以一個排序用的判斷函式來對陣列的元素進行排序。判斷函式包含兩個參數，這兩個參數分別代表陣列裡第 n 個和第 n+1 個元素，透過比較第 n 和第 n+1 個元素的大小來進行排序。\n如果不使用判斷函式的話，預設會將元素轉換成字串，並以首字母的 unicode 來判斷大小。\n 若 compareFunction(a, b) 的回傳值小於 0，則會把 a 排在小於 b 之索引的位置，即 a 排在 b 前面。 若 compareFunction(a, b) 回傳 0，則 a 與 b 皆不會改變彼此的順序，但會與其他全部的元素比較來排序。 若 compareFunction(a, b) 的回傳值大於 0，則會把 b 排在小於 a 之索引的位置，即 b 排在 a 前面。  sort 語法：\narr.sort([compareFunction]); 由於回傳值為負數的話，a 會 排在 b的前面。所以升冪排序陣列的作法如下：\n1 2 3  function compareNumbers(a, b) { return a - b; }   以此類推，降冪排序就改成 b-a：\n1 2 3  function compareNumbers(a, b) { return b - a; }   本題解法 1 2 3 4 5 6 7  // Array.prototype.sort() // 3. Sort the inventors by birthdate, oldest to youngest  let inventors_birth = inventors.sort(function(a,b){ return a.year - b.year; }); console.log(inventors_birth);   \n第四題：把所有發明家的歲數加總 reduce() 方法是做數值累加，會將陣列中的「每一個元素」與下個元素相加，直到結束為止。\n包含一個函式 ( 必填 ) 和初始值 ( 選填 )。\n函式內有四個參數，第一個是累加器 ( 必填 )，第二個是當前元素 ( 必填 )，第三個是該元素的索引值 ( 選填 )，第四個是原本的陣列 ( 選填 )。\nreduce 語法：\narr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue); 本題解法 1 2 3 4 5 6 7  // Array.prototype.reduce() // 4. How many years did all the inventors live all together?  let inventors_live = inventors.reduce(function(total, el){ return total + (el.passed - el.year); }, 0); console.log(inventors_live);   \n第五題：將所有發明家依歲數大小排序 本題使用第三題用過的 sort() 方法。\n本題解法 1 2 3 4 5 6  // 5. Sort the inventors by years lived  let inventors_age = inventors.sort(function(a,b){ return (b.passed - b.year) - (a.passed - a.year); }); console.log(inventors_age);   \n第六題：篩選出中含有「de」的街道名稱 本題要從維基百科的一個資料頁面中撈取資料，並進行過濾篩選。\n從該頁面中撈取出巴黎的街道名稱，並且篩選出中含有「de」的街道名稱。\n本題解法  用 querySelectorAll 撈出頁面的資料 但撈出的資料是偽陣列 NodeList，必須用 from() 方法將其轉為真正的陣列 轉成陣列後，用 map() 方法取出 title 資料組成新陣列 最後用 filter() 和 includes() 方法過濾出有 \u0026lsquo;de\u0026rsquo; 字串的資料  1 2 3 4 5 6 7 8  // 6. create a list of Boulevards in Paris that contain \u0026#39;de\u0026#39; anywhere in the name // https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris  let source = document.querySelectorAll(\u0026#39;.mw-category-group li a\u0026#39;); let toArr = Array.from(source); // 將偽陣列 NodeList 用 from() 方法轉為真正的陣列 let newArr = toArr.map(el=\u0026gt;{return el.title;}); // 用 map() 方法取出 title 資料組成新陣列 let resultArr = newArr.filter(el=\u0026gt;{return el.includes(\u0026#39;de\u0026#39;);}); //用 filter() 和 includes() 方法過濾出有 \u0026#39;de\u0026#39; 字串的資料 console.log(resultArr);   \n第七題：將 people 資料集的人名依首字母排序 本題要將 people 資料集的人名依首字母進行排序。\n除了使用第三題用過的 sort() 方法之外，也結合 slice() 方法擷取出字串的首字母。\nslice(begin, end) 方法會回傳一個新陣列物件，為原陣列選擇之 begin 至 end（不含 end）部分的淺拷貝（shallow copy）。而原本的陣列將不會被修改。\nslice 語法：\narr.slice(begin, end); begin 是選填，若省略了 begin ，則 slice 會從索引 0 開始提取。\n也可使用負數索引，表示由陣列的最末項開始提取。\n例如：slice(-2) 代表拷貝陣列中的最後兩個元素。\nend 也是選填，若省略了 end，則 slice 會提取至陣列的最後一個元素。\n若使用負數索引，表示由陣列的最末項開始提取。\n例如：slice(2,-1) 代表拷貝陣列中第三個元素至倒數第二個元素。\n本題解法 1 2 3 4 5 6 7 8 9  // 7. sort Exercise // Sort the people alphabetically by last name  let alphaArr = people.sort(function(a,b){ let A = a.slice(0, 1); let B = b.slice(0, 1); return A\u0026gt;B ? 1 : B\u0026gt;A ? -1 : 0; }); console.log(alphaArr);   \n第八題：Reduce 練習 本題結合 if 判斷以及物件的特性，來加深對 reduce() 方法的進階應用。\n把題目中所提供的陣列資料，依不同類別分別計算個數。\n本題解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 8. Reduce Exercise // Sum up the instances of each of these  const data = [\u0026#39;car\u0026#39;, \u0026#39;car\u0026#39;, \u0026#39;truck\u0026#39;, \u0026#39;truck\u0026#39;, \u0026#39;bike\u0026#39;, \u0026#39;walk\u0026#39;, \u0026#39;car\u0026#39;, \u0026#39;van\u0026#39;, \u0026#39;bike\u0026#39;, \u0026#39;walk\u0026#39;, \u0026#39;car\u0026#39;, \u0026#39;van\u0026#39;, \u0026#39;car\u0026#39;, \u0026#39;truck\u0026#39; ]; let total = 0; let calcItems = data.reduce((obj,el)=\u0026gt;{ if(!obj[el]){ obj[el] = 1; total++; } else{ obj[el]+=1; total++; } return obj; },{}); console.log(calcItems); console.log(total);   \n 延伸閱讀：\n JS30 Day 4 - Array Cardio Day 學習筆記 JavaScript Array 陣列操作方法大全 ( 含 ES6 ) JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()] 關於 JavaScript 陣列 20 種操作的方法 [六角 Youtube 視頻] JavaScript 陣列處理必學巧技   ","description":"熟悉陣列操作方法：filter()、map()、sort()、reduce()、from()、includes()、slice()","id":2,"section":"posts","tags":["JS30","Javascript"],"title":"【JS30系列】Day 04：Array Cardio Day 1","uri":"https://sylvia-h.github.io/posts/2021/javascript30_day04/"},{"content":"Javascript 30 Day03:\rCSS Variables\r\r Wes Bos 的原始專案：JS30 Day03  Wes Bos 教學影片 Day 03 Day 03 專案完成前 Day 03 專案完成後  專案目標： 利用控制條來調整圖片邊框粗細、邊框色彩以及模糊程度的濾鏡效果。\n我的解法： 實作成果\n1 2 3 4 5 6 7 8 9 10 11  const image = document.querySelector(\u0026#34;img\u0026#34;); function getValue(){ let spacing = document.getElementById(\u0026#34;spacing\u0026#34;).value; let blur = document.getElementById(\u0026#34;blur\u0026#34;).value; let baseColor = document.getElementById(\u0026#34;base\u0026#34;).value; image.style.border = `${spacing}px solid ${baseColor}`; image.style.filter = `blur(${blur}px)`; } document.addEventListener(\u0026#39;mousemove\u0026#39;, getValue);   我的解法比較簡單粗暴一點，主要是用 getElementById 取得元素的值，然後綁定 mousemove 事件監聽。再用 .style 和樣板字面值來修改元素的 class 屬性。\nWes Bos 的解法： Wes Bos 的解法則有意思得多。\n首先是在 CSS 中用了我不太熟悉的 :root 根目錄選取器，同時也是這個範例的核心主題，但我一開始解的時候完全沒有注意到，就直接用自己熟悉的方式來解。等解完再回頭看 Wes Bos 的寫法，才發現到這個主題有使用 :root 根目錄選取器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  :root { --base: #ffc600; --spacing: 10px; --blur: 10px; } img { padding: var(--spacing); background: var(--base); filter: blur(var(--blur)); } .hl { color: var(--base); }   \n再來是 Wes Bos 有運用邏輯運算子 || 的短路求值。\nconst suffix = this.dataset.sizing || '';\n以及用 style.setProperty 簡潔優雅地修改目標元素的 CSS 屬性。\ndocument.documentElement.style.setProperty(\u0026ndash;${this.name}, this.value + suffix);\n1 2 3 4 5 6 7 8 9  const inputs = document.querySelectorAll(\u0026#39;.controls input\u0026#39;); function handleUpdate() { const suffix = this.dataset.sizing || \u0026#39;\u0026#39;; document.documentElement.style.setProperty(`--${this.name}`, this.value + suffix); } inputs.forEach(input =\u0026gt; input.addEventListener(\u0026#39;change\u0026#39;, handleUpdate)); inputs.forEach(input =\u0026gt; input.addEventListener(\u0026#39;mousemove\u0026#39;, handleUpdate));   \n觀念一：input type=”range” type=”range” 的 input 樣式為橫向拉桿，並由 min=\u0026quot;\u0026quot; max=\u0026quot;\u0026quot; 來設定由右至左兩端的極限值，跟其他 input 一樣使用 value=\u0026quot;\u0026quot; 建立預設值。\n觀念二：滑鼠事件 mouse Event mousedown：滑鼠按鍵按下時觸發\nmouseup：滑鼠按鍵放開時觸發\nmousemove：滑鼠指標在指定的元素中移動時觸發。（注意：使用者把滑鼠移動一個畫素，就會發生一次 mousemove 事件。處理所有 mousemove 事件會耗費系統資源。請謹慎使用該事件。）\n 延伸閱讀：\n Mouse Event 小筆記 詳解JavaScript常見滑鼠事件與用法   觀念三：:root 根目錄選取器  建立變數的語法：:root {--variable name: value}  1 2 3 4 5  :root { --base: #ffc660; --spacing: 10px; --blur: 10px; }   \n 套用變數的語法：var(--variable name)  1 2 3 4 5 6 7 8 9  img { padding: var(--spacing); background: var(--base); filter: blur(var(--blur)); } .hl { color: var(--base); }   \n 延伸閱讀：\n :root 根目錄選取器 - 叫你阿爸出來講   觀念四：style.setProperty 為目標元素設置新的 CSS 屬性值 語法：style.setProperty(propertyName, value, priority);\npriority 可以填入 “important” 如果没有指定，就是空字串。`\n 延伸閱讀：\n MDN | CSSStyleDeclaration.setProperty()   ","description":"利用控制條來調整圖片邊框粗細、邊框色彩以及模糊程度的濾鏡效果","id":3,"section":"posts","tags":["JS30","Javascript"],"title":"【JS30系列】Day 03：CSS Variables","uri":"https://sylvia-h.github.io/posts/2021/javascript30_day03/"},{"content":"Javascript 30 Day02:\rCSS \u0026#43; JS Clock\r\r Wes Bos 的原始專案：JS30 Day02  Wes Bos 教學影片 Day 02 Day 02 專案完成前 Day 02 專案完成後  專案目標： 製作一個時、分、秒針能實時運轉的小時鐘。\n我的解法： 實作成果\n1 2 3 4 5 6 7 8 9  .hand { width: 0; height: 0; position: absolute; top: 50%; border-style: solid; border-width: 3px 15rem 3px 0; transform-origin: 100%; }   \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  const hourHand = document.querySelector(\u0026#39;.hour-hand\u0026#39;); const minHand = document.querySelector(\u0026#39;.min-hand\u0026#39;); const secondHand = document.querySelector(\u0026#39;.second-hand\u0026#39;); const hourInfo = document.querySelector(\u0026#39;.hour-info\u0026#39;); const minInfo = document.querySelector(\u0026#39;.min-info\u0026#39;); const hourDeg = 360 / 12; const minDeg = 360 / 60; const secondDeg = 360 / 60; function setTime(){ const NOW = new Date(); const nowHour = NOW.getHours(); const nowMin = NOW.getMinutes(); const nowSecond = NOW.getSeconds(); const hourTranDeg = (nowHour % 12)*hourDeg + nowMin/2; const minTranDeg = nowMin*minDeg; const secondTranDeg = nowSecond*secondDeg; hourHand.style.transform = `rotate(${hourTranDeg+90}deg)`; minHand.style.transform = `rotate(${minTranDeg+90}deg)`; secondHand.style.transform = `rotate(${secondTranDeg+90}deg)`; hourInfo.innerText = nowHour; minInfo.innerText = nowMin; hourInfo.style.transform = `rotate(${360-(hourTranDeg+90)}deg)`; minInfo.style.transform = `rotate(${360-(minTranDeg+90)}deg)`; } setInterval(setTime, 1000); setTime();   \n觀念一：new Date() 抓取當前時間 建立一個變數來存取當前時間資訊。\n其中包含年、月、日、時、分、秒資訊。\n1 2  const NOW = new Date(); // Wed Oct 20 2021 19:36:34 GMT+0800 (台北標準時間) {}   \n觀念二：getHours()、getMinutes()、getSeconds()獲取當前時、分、秒資訊 使用 getHours()、getMinutes()、getSeconds() 方法來從剛剛建立的 NOW 變數中分別提取時分秒資訊。\n1 2 3  const nowHour = NOW.getHours(); const nowMin = NOW.getMinutes(); const nowSecond = NOW.getSeconds();   \n觀念三：transform-origin 設定旋轉軸心 transform-origin 可以用來設定旋轉軸心。\n由於指針初始設定是由時鐘正中心指向 9 點鐘方向，所以設定的軸心是指針的最右側，故在此範例中 transform-origin 設定為 100%。\n並搭配 transform: rotate(90deg); ，以 0 點為起點開始旋轉，所以要先旋轉 90 度。\n 延伸閱讀：\n CSS-transform-origin 軸心   觀念四：setInterval 設定間隔時間，重複執行程式 setTimeout() 方法用於在指定的毫秒數後呼叫函式或計算表示式。\nsetInterval() 方法則是在每隔指定的毫秒數迴圈呼叫函式或表示式，直到clearInterval把它清除。\n也就是說 setTimeout() 只執行一次，setInterval() 可以執行多次。\n因為在此範例中是每秒都要重新獲取一次時間資訊，所以使用 setInterval()。\n","description":"製作一個時、分、秒針能實時運轉的小時鐘","id":4,"section":"posts","tags":["JS30","Javascript"],"title":"【JS30系列】Day 02：CSS + JS Clock","uri":"https://sylvia-h.github.io/posts/2021/javascript30_day02/"},{"content":"Javascript 30 Day01:\rJavaScript Drum Kit\r\r Wes Bos 的原始專案：JS30 Day01  Wes Bos 教學影片 Day 01 Day 01 專案完成前 Day 01 專案完成後  專案目標：  按下與畫面上對應的鍵盤按鍵時，相應的方框會稍微放大字體 外框會發出黃色光暈 同時撥放音檔  我的解法： 實作成果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  document.addEventListener(\u0026#39;keydown\u0026#39;, pressKey); document.addEventListener(\u0026#39;keyup\u0026#39;, upKey); function pressKey(e) { keyElement = document.querySelector(`.key[data-key=\u0026#34;${e.keyCode}\u0026#34;]`); keyElement.classList.add(\u0026#39;playing\u0026#39;); audioElement = document.querySelector(`audio[data-key=\u0026#34;${e.keyCode}\u0026#34;]`); audioElement.play(); } function upKey(e) { keyElement = document.querySelector(`.key[data-key=\u0026#34;${e.keyCode}\u0026#34;]`); keyElement.classList.remove(\u0026#39;playing\u0026#39;); }   \n觀念一：鍵盤事件 KeyBoard Event KeyCode 對照表\n e.keyCode：綁定「按下鍵盤按鍵（keydown \u0026amp; keypress）」、「放開鍵盤按鍵（keyup）」等事件監聽，可以獲取按下的鍵盤按鍵的 Unicode 值。 keydown：按下鍵盤（任何的鍵盤按鍵）的那個剎那會觸發此事件 keypress：按下鍵盤（可以輸出文字符號的按鍵）的那個剎那會觸發此事件 keyup：放開鍵盤的那個剎那，會觸發此事件   延伸閱讀：\n 鍵盤事件keypress 和 keydown、keyup 的用法與區別 比較 keydown, keypress, keyup 的差異   觀念二：data-取值  用 getAttribute() 方法取得 DOM 元素的 data- 屬性  1  \u0026lt;div id=\u0026#34;myDiv\u0026#34; data-appid=\u0026#34;123\u0026#34; data-myname=\u0026#34;Sylvia\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   1 2 3  let dataDiv = document.getElementById(\u0026#34;myDiv\u0026#34;); console.log(dataDiv.getAttribute(\u0026#34;data-appid\u0026#34;)); // 123 console.log(dataDiv.getAttribute(\u0026#34;data-myname\u0026#34;)); // Sylvia   \n 用 querySelector() 方法 + 樣板字面值 [data-key=\u0026quot;${e.keyCode}\u0026quot;] 取得具有某 data- 屬性的 DOM 元素  1 2  keyElement = document.querySelector(`.key[data-key=\u0026#34;${e.keyCode}\u0026#34;]`); audioElement = document.querySelector(`audio[data-key=\u0026#34;${e.keyCode}\u0026#34;]`);   \n","description":"JS30 是由加拿大工程師Wes Bos所設計的一系列課程，其設計宗旨是不使用任何的框架或library，只以Vanilla JS（純 JavaScript）為主要開發工具來完成 30 個小專案，藉由這一系列的練習來熟悉 DOM 操作與各種原生 API 應用。","id":5,"section":"posts","tags":["JS30","Javascript"],"title":"【JS30系列】Day 01：JavaScript Drum Kit","uri":"https://sylvia-h.github.io/posts/2021/javascript30_day01/"},{"content":"Javascript 的參數傳遞:\rby reference (傳址/傳參考)、by value（傳值）和 by sharing（傳共享）\r\r 從比較運算子來釐清基本觀念 在正式進入這個主題之前，我們先來複習一下 JavaScript 的基本觀念。首先是「比較運算子」：\n1 2 3  let a = 3; let b = 3; console.log(a === b);   上面這題印出的答案是甚麼呢？沒錯，是 true。\n看到這邊，你可能會想翻桌，這麼簡單的問題還要問嗎？值與型別都相同，用嚴格相等比較運算子（===），結果當然是 true 啊。\n先壓壓怒氣，再來看看下面這題：\n1 2 3  let c = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;]; let d = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;]; console.log(c === d);   「廢話，當然也是 true 啊！」\n你確定嗎？\n那麼下面這幾題呢？\n1 2 3 4  console.log( [] === [] ); console.log( [1] === [1] ); console.log( {} === {} ); console.log( {a:1} === {a:1} );   執行以上五個判斷式的結果是什麼呢？\n結果竟然全部是 false ！\n原因就在於 Javascript 中不同型別的變數會有不同的儲存和傳遞資料的方式，大致上可以分為 「傳值」(call/pass by value) 和 「傳址（也有譯為「傳參考」）」(call/pass by reference) 兩種。\n參數的傳遞方式 以傳統的說法來說，若變數指派的值為基本型別（number、string、boolean、null、undefined、symbol），那麼賦值是「傳值」。\n若變數指派的值為物件型別（object、array、function），那麼賦值是「傳址」。\n   型別 參數傳遞方式 英譯     基本型別（number、string、boolean、null、undefined、symbol） 傳值 by value   物件型別（object、array、function） 傳址/傳參考 by reference    但為什麼說上面這個說法是「傳統說法」呢？\n因為也有人認為 Javascript 既不是傳值也不是傳址，而是「有時看起來像傳值，有時看起來像傳址」， 實際上應該說是「傳共享（pass/call by sharing）」 。\n但也有人認為 Javascript 沒有所謂的「傳址」或「傳共享」，實際上就只有「傳值」(call/pass by value)。\n這眾說紛紜的狀況是怎麼回事呢？要釐清這道經典的爭議題，就讓我們先從傳統的說法來理解何謂「傳值」？何謂「傳址」？\n何謂「傳值（call/pass by value）」？ 對電腦來說，實際儲存和呼叫資料是以「記憶體位址」來運作，而宣告變數，就是來幫助我們以別名來與實際的資料儲存位址作連結。變數會指向記憶體位置來調用資料進行運算。\n1  let a = 3;   比如說，當我們宣告一個變數 a ，並賦值一個資料型別為數字的值 3 的時候，實際上在電腦中是這樣運作的：\n 將 3 這個值儲存在 0x01 這個記憶體位置，然後把變數 a 指向這個記憶體位置。\n如果此時宣告一個新變數 b，並把變數 a 的值賦值給變數 b：\n1 2  let a = 3; let b = a;   那麼記憶體位置 0x01 中儲存的值 3 就會被複製一份到 0x02 ，並將新變數 b 指向記憶體位置 0x02。（如下圖）\n 這就是所謂的「傳值」。\n也就是當 變數指派的值是基本型別 時，變數間做 = 賦值時，傳遞的是變數的值。\n此時，不同變數雖然值相同，但依舊是儲存在不同的記憶體位址。\n若這時對其中一個變數再重新賦值的話，另一個變數的值並不會因此而更動：\n1 2 3 4 5 6 7 8 9 10 11  let a = 3; let b = a; console.log( a ); // 3 console.log( b ); // 3  a = 5; // 變數 b 依然是 3，而變數 a 變成了 5 console.log( a ); // 5 console.log( b ); // 3   \n 當變數的值為基本型別時，若對該變數重新賦值的話，並不是直接修改值的資料內容，而是在記憶體內部重新分配一個區塊存放新的值，變數就指向新分配的記憶體區塊，原本舊的記憶體區塊還是放著舊值，所以舊值其實是不可變動的（immutable）。有 by value 特性的資料型別大多是不可變動的（immutable）。\n何謂「傳址（call/pass by reference）」？ 若變數指派的值為物件型別（object、array、function），那麼賦值就是「傳址」。\n這又是甚麼意思呢？\n因為物件型別儲存的是物件中的每個屬性（property），一個屬性包含一組「鍵」（key）和「值」（value），一組「鍵值對（Key-Value Pairs）」稱做物件的一個屬性。\n這組「鍵值對」儲存的方式是：儲存屬性「鍵（key）」的值 以及 儲存屬性「值（value）」的記憶體位置。（觀念來源：JavaScript - 參數傳遞方式 (2)）\n我將我對這段話的理解，繪製成下圖：\n 也就是變數 obj 指向的記憶體位置 0x03 儲存了一個物件型別的資料，該物件有兩個屬性，第一個屬性的「鍵」 key0 的「值」是記憶體位置 0x01 ，而 0x01 儲存了一個字串型別的資料 \u0026quot;aa\u0026quot;。第二個屬性的「鍵」 key1 的「值」是記憶體位置 0x02 ，而 0x02 儲存了一個字串型別的資料 \u0026quot;bb\u0026quot;。\n若此時欲將變數 obj 的值，賦值給變數 obj2：\n1 2 3 4 5  let obj = { key0: \u0026#34;aa\u0026#34;, key1: \u0026#34;bb\u0026#34; }; let obj2 = obj;   電腦底層的運作方式是如何呢？\n剛剛處理基本型別的值，用的是傳值（call/pass by value）的方式。如果物件型別也用一樣的方法的話，那麼應該就是將記憶體位置 0x03 的物件型別資料複製一份到記憶體位置 0x04，再將變數 obj2 指向記憶體位置 0x04。\n可是，如果我們以這個概念來操作以下程式碼的話，就會發現狀況有點不一樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let obj = { key0: \u0026#34;aa\u0026#34;, key1: \u0026#34;bb\u0026#34; }; // 先將 obj 賦值給 obj2 let obj2 = obj; console.log(obj); // {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;}; console.log(obj2); // {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;};  // 再對 obj 物件的第一個鍵值重新賦值 obj.key0 = \u0026#34;cc\u0026#34;; console.log(obj); // {key0: \u0026#34;cc\u0026#34;,key1: \u0026#34;bb\u0026#34;}; console.log(obj2); // {key0: \u0026#34;cc\u0026#34;,key1: \u0026#34;bb\u0026#34;};  console.log(obj===obj2); // true   如果變數 obj2 指向的是記憶體位置 0x04，那麼第二次 console.log 時，印出來的結果應該會不一樣才對。但是變數 obj 和 變數 obj2 卻印出一樣的結果！\n也就是說，下圖用「傳值」的方式來理解物件型別的參數傳遞是錯誤的：\n 正確的理解是，當變數指派的值是物件型別時，變數間做 = 賦值時，傳遞的是變數的記憶體位址，即所謂「傳址」。\n 這樣的話，剛剛那段程式碼的運作邏輯，就解釋得通了。\nobj.key0 = \u0026quot;cc\u0026quot;; 是將字串 \u0026quot;cc\u0026quot; 儲存在新的記憶體位置，再將 obj.key0 指向新的記憶體位置，但是原先儲存整個物件資料的記憶體位置並沒有變動，由於 obj 和 obj2 儲存的是同一個記憶體位置，所以 obj === obj2 的結果會是 true。\n真正變動的只有屬性的值所指向的記憶體位置。\n 這時我們再回過頭來看，一開始關於嚴格相等比較運算子（===）的那道題目，就可以理解答案是 false 的原因了：\n1 2 3  let c = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;]; let d = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;]; console.log(c === d); // false   因為 變數c 和 變數d 所儲存的物件資料，其值所指向的記憶體空間並不相同，因此嚴格比對下的結果會是 false。\n關於 immutable 和 mutable 的觀念 在上面的例子中，實際修改物件的值時，將會修改到的是物件的值所參考到的記憶體位置，可以發現舊值是可變動的（mutable)。\n這裡就帶出了 「不可變的（immutable）」 和 「可變的（mutable）」 的兩種觀念。\n當變數的值為基本型別時，若要修改值，其實是在記憶體內部重新分配一個區塊存放新的值，而變數就會指向新分配的記憶體區塊，原本舊的記憶體區塊還是放著舊值，所以舊值為 immutable。\n有 by value 特性的資料型別大多是 immutable。\n Object, Array, Function, Map 和 Set 等物件型別，在實際修改物件的值時，將會修改到的是物件的值所參考到的記憶體位置，所以舊值為 mutable。\n有 by reference 特性的型別大多是 mutable。\n 關於 pass by sharing 的討論 而物件型別的「傳址」又還有一個例外情況，故又有討論認為 Javascript 的策略其實不是「傳值（call/pass by value）」，也不是「傳址（call/pass by reference）」而是「傳共享（call/pass by sharing）」。\n這點就見仁見智了，此處對於 Javascript 究竟是不是該歸屬於「pass by sharing」不去細究，想進一步了解的話可再從下方的參考資料中去延伸閱讀。\n此處只對這個例外情況稍作說明，這個例外情況是什麼呢？\n就是當變數的值為物件型別，變數間做 = 賦值時，傳遞的是變數的記憶體位址，即「傳址」，但如果此時又再對其中一個變數用 物件實字（object literal） 的方式重新賦值，或在物件中加入新的 key 屬性的話，那麼，原本指向同一個記憶體位址的兩個變數，其中重新賦值的那個變數會指向不同的記憶體位址來儲存新的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let obj = { key0: \u0026#34;aa\u0026#34;, key1: \u0026#34;bb\u0026#34; }; // 將 obj 的記憶體位址，賦值「傳址」給 obj2 let obj2 = obj; // obj 和 obj2 此時指向同一個記憶體位址 console.log(obj); // {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;}; console.log(obj2); // {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;};  // 以物件實字重新對 obj 賦值 obj = { key3: \u0026#34;cc\u0026#34; }; console.log(obj); // {key3: \u0026#34;cc\u0026#34;}; console.log(obj2); // {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;};  // obj2 仍是 {key0: \u0026#34;aa\u0026#34;,key1: \u0026#34;bb\u0026#34;}; // obj 卻被指向新的記憶體位址，且不會影響的 obj2 的值   \n 前一章節探討物件型別的值，有說到物件型別的舊值為「可變動的（mutable）」，但從上面這個例子來看，以物件實字重新賦值時，舊值並非「可變動的（mutable）」，而是指向新的記憶體位置，這個狀況似乎比較像基本型別「不可變動的（immmutable）」性質以及「傳值」的運作方式。\n是不是覺得之前說的「傳值」和「傳址」觀念有點開始崩裂了呢？\n再來看另外一種例外狀況，是經由第三方函式來傳遞參數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 宣告一個物件 obj let obj = { key0: \u0026#34;aa\u0026#34;, key1: \u0026#34;bb\u0026#34; }; function changeObj(xyz){ console.log(xyz);\t// {key0: \u0026#39;aa\u0026#39;, key1: \u0026#39;bb\u0026#39;}  // 對物件的第一個鍵值重新賦值 \txyz.key0 = \u0026#34;cc\u0026#34;; console.log(xyz);\t// {key0: \u0026#39;cc\u0026#39;, key1: \u0026#39;bb\u0026#39;} } // 以第三方函式傳值 changeObj(obj); // obj 的第一個鍵值確實被改動了 console.log(obj);\t// {key0: \u0026#39;cc\u0026#39;, key1: \u0026#39;bb\u0026#39;}   在上面的例子中，因為是「傳址」，所以物件 obj 的第一個鍵值確實被更動了。\n但如果用在第三方函式中以物件實字（object literal）重新賦值呢？卻變成了「傳值」的運作模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 宣告一個物件 obj let obj = { key0: \u0026#34;aa\u0026#34;, key1: \u0026#34;bb\u0026#34; }; function changeObj(xyz){ console.log(xyz);\t// {key0: \u0026#39;aa\u0026#39;, key1: \u0026#39;bb\u0026#39;} \txyz = {key2:\u0026#34;cc\u0026#34;}; console.log(xyz);\t// {key2: \u0026#39;cc\u0026#39;} } // 以第三方函式傳值 changeObj(obj); // 但結果 obj 的值並未更動 console.log(obj);\t// {key0: \u0026#39;aa\u0026#39;, key1: \u0026#39;bb\u0026#39;}   在上面這個例子中，把 obj 傳入函式 changeObj(obj); 裡面，並對 obj 重新賦值。如果物件型別的值是「傳址」的話， obj 應該會被指向新的記憶體位置，且其值會變成 {key2: 'cc'}。\n但最後結果卻是 obj 並未被更動，仍維持舊值。\n這樣看來，物件型別的值在參數的傳遞上，既不是 pass by value 也不是 pass by reference。\n由於有這些奇怪的狀況，所以才有說法認為 Javascript 不是「傳值（by value）」，也不是「傳址（by reference）」而是「傳共享（pass by sharing）」。\n意思就是說，讓 function 裡面 xyz 跟外面的 obj 「共享」同一個 object，所以可以透過 function 裡面的 xyz 修改「共享到的那個 object」的資料。\n其實 Javascript 實際上就只有「傳值(by value)」 看到這個副標，你大概會想：「很好，現在又是甚麼狀況？」\n會產生這些眾說紛紜的說法，原因在於大家對於 Value 和 Reference 的定義不同。\n我們來回頭看看剛剛解釋「by reference」所使用的圖：\n 如果把記憶體位置 0x03 視作變數 obj 和 obj2 所儲存的值，那麼其實「pass by reference」也可以說是「pass by value」的一種，只是這個 value 是 reference 而已。\n關於這個問題的討論相當多而且複雜，以上只是我以自己所能理解的程度做的簡單整理。而對於 Javascript 究竟是「pass by sharing」還是只有「pass by value」，就留待諸君各自判斷了。\n 參考資料：\n 談談 JavaScript 中 by reference 和 by value 的重要觀念 重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？ JavaScript 的「傳值」與「傳址」 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ 理解 mutable VS immutable 物件 [JavaScript] Javascript中的傳值 by value 與傳址 by reference 林儀泰：簡單介紹JavaScript參數傳遞 I Want To Know JS系列 第 7 篇：JavaScript - 參數傳遞方式 (1) I Want To Know JS系列 第 8 篇：JavaScript - 參數傳遞方式 (2) 你不可不知的 JavaScript 二三事#Day26：程式界的哈姆雷特 —— Pass by value, or Pass by reference？ call by value 傳值 \u0026amp; call by reference 傳址   ","description":"Javascript 是「傳值」（call/pass by value）還是「傳址（也有譯為「傳參考」）」（call/pass by reference）？可說是 Javascript 的萬年爭議經典題目。究竟兩者定義為何？有甚麼差別？另外 call/pass by sharing（傳共享）又是甚麼呢？","id":7,"section":"posts","tags":["Javascript"],"title":"Javascript 的參數傳遞：by reference（傳址/傳參考）、by value（傳值）和 by sharing（傳共享）","uri":"https://sylvia-h.github.io/posts/2021/1013_byvalue_reference_sharing/"},{"content":"型別名詞釋義:\r靜態型別 動態型別 隱性型別 強型別 弱型別\r\r 在釐清 Javascript 的資料型別的過程中，一不小心踏入了這個名詞坑。\n一開始只是想釐清 Javascript 的資料型別，讀到 MDN 一篇關於 JavaScript 的資料型別與資料結構的文章，文中出現「動態型別」一詞來說明 Javascript 的特性，為了弄清楚該詞的意思，結果一腳踏入無底坑洞\u0026hellip;\n既然時間都花下去了，就來整理一下筆記吧。\n靜態型別、編譯式語言 靜態型別的語言(statically typed language)在型別的管理上十分嚴謹，在語法撰寫時就會要求對變數型別有明確定義。\n例如：\n1  int x;   宣告變數的時候就已經規定了未來存入的值是怎樣的資料型別，如果已經用 int 宣告了 x，就代表 x 將不能被放入字串資料，而只能放入整數。\n在變數宣告與初始化階段就把變數和型別進行靜態綁定，就稱之為 「靜態型別的語言」。\n編譯式語言多半會是靜態型別的語言，在編譯時期就會事先定義的型別，進行型別檢查，若出現變數誤用，資料型態不正確的話，在編譯時期就能發現，降低執行時期的風險。\nC、C++、Rust、Go、Visual Basic、Swift、Obj-C、Java 和 C# 就是屬於編譯式語言。\n而什麼是編譯式語言呢？\n也就是程式執行前先透過編譯器(compiler)將程式碼編譯後再執行的語言，就稱為編譯式語言(Compiled language)。過程如下：\n程式碼 \u0026mdash;\u0026gt; 編譯器(compiler) \u0026mdash;\u0026gt; 機器碼(machine language) 隱性型別(implicitly typed)的靜態語言 有些靜態語言在宣告時，也不需要指定型別，而是透過隱性推導的方式來確認型別。例如傳統 C# 宣告變數時需要指定型別：\n1  int x = 123;   但到了 C# 4.0 ，宣告變數就可以不用指定型別：\n1  var n = 456;   但是其型別就是初始值的型別，宣告時已經進行初始化，不能在中途任意改變型別，所以骨子裡還是靜態型別語言，稱為隱性型別(implicitly typed)的靜態語言。\n不同於隱性型別是透過編譯過程的推導而得知型別，顯性型別(explicitly typed)則是將型別作為語法宣告的一部份。\n動態型別、直譯式語言 動態型別的語言(dynamically typed language)相較於靜態型別的語言，在型別的處理上較鬆散靈活。\n以 Javascript 為例：\n1 2 3 4 5 6 7  let x; x=\u0026#34;Hello\u0026#34;; console.log(x); x=12; console.log(x);   宣告變數 x 時，沒有明確指定 x 的型別，代表能放入任意類型的資料；在賦值為 \u0026quot;Hello\u0026quot; 字串後，又改變賦值的資料型態放入整數 12，即便這樣改換資料型別，但程式依然可以成功運作。\n這表示動態型別的語言在程式執行過程才會進行資料型態的檢查或確認，到執行階段才能夠明確變數的型別，而且變數的型別隨時可以變化，因此直譯式語言(Interpreted language)都是動態型別語言。如 Python、PHP、Ruby、JavaScript，都屬於此類語言。\n直譯式語言在執行時，才會一行一行的動態將程式碼直譯(interpret)為機器碼並執行，因此速度上會比編譯式語言要慢。其緩慢的運行速度是直譯語言最大的壞處。\n動態/靜態/編譯/直譯，各型別差異 執行速度 v.s. 開發速度 雖然就執行時期的執行速度而言，編譯語言會比直譯語言來得快；然而，編譯語言的壞處是編譯時期的程式開發和除錯速度比較慢，不能像直譯語言一樣，開發一小段程序便立刻運行。\n執行環境 編譯語言由編譯器進行型別和語意檢查後，編譯完成的執行檔是可以獨立運行的，程式碼能直接存取系統服務 (system service) 與 APIs，因此執行效率特別好。\n但直譯語言則必須依賴一個執行環境 (execution context)才可以執行。\n例如 JavaScript 只能使用瀏覽器提供的功能，它無法獨立執行 (看起來像獨立執行，實際上卻是系統自動在背後建立執行環境，如 HTML Application)；或是像 Python3 程式碼需要有在有安裝 Python3 的電腦中才可以運行。\n即時編譯 編譯語言開發與除錯速度慢，而直譯語言執行速度慢，若能同時改善兩者缺點、取其優點，豈不理想？！\n思及此，因而發展出即時編譯的技術。這種技術混合了編譯語言與直譯語言的優點，如同編譯語言，會先把程式原始碼編譯成中介碼 (Bytecode)。到執行期時，再將中介碼直譯之後執行。\n使用即時編譯技術的語言會比純編譯語言來的慢一些，但是卻又擁有直譯語言的特性。Java、C# 就是其中代表。\n強型別、弱型別 靜態型別、動態型別指的是變數與型別的綁定方法。\n強型別、弱型別 則是 執行階段時，型別轉換的容許程度；也可以說是語言型別系統(Type System)的編譯器或直譯器對型別檢查的寬容程度、嚴格程度、型別安全的程度。\n強型別指的是「程式所定義的變數型別等於變數在執行時期的型別」。\n例如，Java 為例，企圖在數字運算過程混進一個字串：\n1  int x = 123 + \u0026#34;456\u0026#34;;   就會產生編譯錯誤，這就是屬於強型別。\n但如果是 PHP 的話：\n1 2  $x = 123 + \u0026#34;456\u0026#34;; echo $x;   字串與數字相加的執行結果會出現 579，是可以運行成功的。表示 PHP 的直譯器能夠容忍隱性的型別轉換，也就弱型別。\n雖然常看到的靜態語言大部分是強型別。但這並不代表靜態語言一定是強型別、動態語言一定是弱型別。例如：Python 雖然是動態語言，但在型別判斷的嚴格程度上，Python 是一個強型別。\n常見語言的型別特性 這個部份真的要大推 2019 iT 邦幫忙鐵人賽的你不可不知的 JavaScript 二三事系列 Day3，該文將動態靜態強弱型別整理得非常清楚！\n以下也是把該文的整理結果擷取過來。\n幾種常見程式語言的型別特性：\n   靜態語言／動態語言 強型別／弱型別 程式語言     靜態 強 Java, C#   靜態 弱 C/C++   動態 強 Python, Ruby   動態 弱 Perl, PHP, JavaScript    靜態語言又分顯性型別和隱性型別：\n靜態顯性型別：Java, C\n靜態隱性型別：Ocaml, Haskell\n各語言所處的型別象限：\n由以上的象限圖可以看出作為動態網頁不可缺少的角色 \u0026mdash; Javascript，所處的位置是動態型別，而且是比 PHP 還要弱的弱型別。（哭哭）\n原因在於 Javascript 在處理數學運算和字串串接的時候，算數運算子和串接運算子都是「+」，這就是為什麼 JavaScript 常常容易出現一些意想不到的相加結果。雖然 PHP 是屬於弱型別，對不同型別也會做出隱式轉換，但 PHP 進行字串串接的時候會使用「.」作為串接運算子，在數學運算和字串串接上稍稍有所區隔，因此弱型別的程度沒有 Javascript 嚴重。這部分的討論可以參考這邊。\n 參考資料：\n MDN　|　JavaScript 的資料型別與資料結構 維基百科 - 強弱型別 Day 2：資料型態的夢魘——動態型別加弱型別(1) Day 3：資料型態的夢魘——動態型別加弱型別(2) Day 4：動態型別加弱型別不是罪——怎麼 JavaScript 一摔就變成個印度阿三？ 淺談程式語言型別的強型別，弱型別，動態型別，靜態型別 編譯語言 VS 直譯語言 動態型別語言\u0026amp;動態語言 淺談程式語言型別的強型別，弱型別，動態型別，靜態型別 重新認識 JavaScript: Day 03 變數與資料型別   ","description":"編譯式語言和直譯式語言牽涉到許多個關於「型別」的名詞，一下子讓人墜入五里霧中，這篇筆記把我所看到的資料進行整理，將這些名詞的定義與關聯性做個簡單的報告。","id":8,"section":"posts","tags":["Javascript"],"title":"型別名詞釋義：靜態型別/動態型別/隱性型別/強型別/弱型別","uri":"https://sylvia-h.github.io/posts/2021/0919_language-type/"}]